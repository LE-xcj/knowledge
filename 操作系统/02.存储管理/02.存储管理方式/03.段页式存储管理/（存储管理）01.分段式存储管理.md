虽然分页式存储管理提高内存利用率，但是也引起了另外一个问题。

那就是分页式存储管理会将一个逻辑上独立的程序段分为多个页，并可能加载到不连续的内存中。这样整个程序段的连续性遭到了破坏。

从人的视角来看，一个作业应该按照逻辑关系进行分段，并以段为单位来分配和回收能；因此分段式存储管理就诞生了。

**分配基本单位：段**

分段式与分页式存储管理都是采用动态重定位技术来进行地址转换，主要区别在于它们的分配单位的不同，分段式存储管理的基本单位：段。

作业是由若干个逻辑分段组成，每个段都是逻辑意义完整的信息集合。且每个段的内存空间必须是连续的，而段与段之间可以不连续，大小各不相同。段的结构如下：

![](http://mmbiz.qpic.cn/mmbiz_png/BWLbK9PgqK3cFyVBBjx4fN1prBd5Ye4sWasia7Px6j7rm55PibEaH2cJqZ2UYicJdiaOdThyK3IKPUOp2lYj1eVkbA/0?wx_fmt=png)

地址重定位：

从逻辑地址到物理地址的转换，离不开段表（SMT，Segment Tbale）。而转换的过程如下：

![](http://mmbiz.qpic.cn/mmbiz_png/BWLbK9PgqK3cFyVBBjx4fN1prBd5Ye4sVF9GQRybrDpZiaibYW7dGrTB4fez2AsSLsH1PFGibx1EwlCGb3Z5ZPic8w/0?wx_fmt=png)

1、从逻辑地址提取段号，然后与段表寄存器的段表长度进行比较

1.1、段号 > 段表长度，越界中断

1.2、段号 <= 段表长度，则进入 2

2、结合段表寄存器的段表起始地址以及逻辑地址的段内位移，找到对应的记录

2.1、段内位移 > 段长，越界中断

2.2、段内位移 <= 段长，那就将内存始址与段内位移相加，得到物理地址

分页和分段的区别：

![](http://mmbiz.qpic.cn/mmbiz_png/BWLbK9PgqK3cFyVBBjx4fN1prBd5Ye4sVg4667xuwtsu6Iia6lmGICA8SPFOXr3mJetaU5rpg5ibpXMicv0HwD4tg/0?wx_fmt=png)
